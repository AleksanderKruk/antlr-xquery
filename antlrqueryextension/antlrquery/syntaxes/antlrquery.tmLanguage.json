{
  "$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
  "name": "antlrquery",
  "scopeName": "source.antlrquery",
  "patterns": [
    { "include": "#double_quoted_strings" },
    { "include": "#single_quoted_strings" },
    { "include": "#variables" },
    { "include": "#block_comments" },
    { "include": "#numeric_literals" },
    { "include": "#types" },
    { "include": "#functions" },
    { "include": "#custom_types" },
    { "include": "#operators" },
    { "include": "#keywords" }
  ],
  "repository": {
    "operators": {
      "patterns": [
        { "name": "keyword.operator.pipe-arrow.antlrquery", "match": "->" },
        { "name": "keyword.operator.mapping-arrow.antlrquery", "match": "=!>" },
        { "name": "keyword.operator.question-mark.antlrquery", "match": "\\?" },
        { "name": "keyword.operator.eq.antlrquery", "match": "\\beq\\b" },
        { "name": "keyword.operator.ne.antlrquery", "match": "\\bne\\b" },
        { "name": "keyword.operator.lt.antlrquery", "match": "\\blt\\b" },
        { "name": "keyword.operator.le.antlrquery", "match": "\\ble\\b" },
        { "name": "keyword.operator.gt.antlrquery", "match": "\\bgt\\b" },
        { "name": "keyword.operator.ge.antlrquery", "match": "\\bge\\b" },
        { "name": "keyword.operator.concatenation.antlrquery", "match": "\\|\\|" },
        { "name": "keyword.operator.union.antlrquery", "match": "\\|" },
        { "name": "keyword.operator.exclamation.antlrquery", "match": "!" },
        { "name": "keyword.operator.minus.antlrquery", "match": "-" },
        { "name": "keyword.operator.arrow.antlrquery", "match": "=>" },
        { "name": "keyword.operator.eq-op.antlrquery", "match": "=" },
        { "name": "keyword.operator.ne-op.antlrquery", "match": "!=" },
        { "name": "keyword.operator.lt-op.antlrquery", "match": "<" },
        { "name": "keyword.operator.gt-op.antlrquery", "match": ">" },
        { "name": "keyword.operator.ge-op.antlrquery", "match": ">=" },
        { "name": "keyword.operator.le-op.antlrquery", "match": "<=" },
        { "name": "keyword.operator.preceding.antlrquery", "match": "<<"},
        { "name": "keyword.operator.following.antlrquery", "match": ">>"},
        { "name": "keyword.operator.assignment.antlrquery", "match": ":=" },
        { "name": "keyword.operator.slashes.antlrquery", "match": "//" },
        { "name": "keyword.operator.slash.antlrquery", "match": "/" },
        { "name": "keyword.operator.is.antlrquery", "match": "\\bis\\b" },
        { "name": "keyword.operator.div.antlrquery", "match": "\\bdiv\\b" },
        { "name": "keyword.operator.div-op.antlrquery", "match": "รท" },
        { "name": "keyword.operator.idiv.antlrquery", "match": "\\bidiv\\b" },
        { "name": "keyword.operator.star.antlrquery", "match": "\\*" },
        { "name": "keyword.operator.plus.antlrquery", "match": "\\+" },
        { "name": "keyword.operator.mod.antlrquery", "match": "\\bmod\\b" },
        { "name": "keyword.operator.multiplication.antlrquery", "match": "\\bx\\b" },
        { "name": "keyword.operator.comma.antlrquery", "match": "," }
      ]
    },

    "keywords": {
      "patterns": [
        {
          "name": "keyword.control.antlrquery",
          "match": "\\b(if|while|for|return|allowing|ancestor|ancestor-or-self|and|array|as|ascending|at|attribute|base-uri|boundary-space|by|case|cast|castable|catch|child|collation|comment|construction|context|copy-namespaces|count|decimal-format|decimal-separator|declare|default|descendant|descendant-or-self|descending|digit|div|document|document-node|element|else|empty|empty-sequence|encoding|end|enum|eq|every|except|exponent-separator|external|false|finally|fixed|fn|following|following-or-self|following-sibling|following-sibling-or-self|follows|for|function|ge|get|gnode|greatest|group|grouping-separator|gt|idiv|if|import|in|infinity|inherit|instance|intersect|is|is-not|item|jnode|key|lax|le|least|let|lt|map|member|minus-sign|mod|module|namespace|namespace-node|NaN|ne|next|no-inherit|no-preserve|node|of|only|option|or|order|ordered|ordering|otherwise|parent|pattern-separator|per-mille|percent|precedes|preceding|preceding-or-self|preceding-sibling|preceding-sibling-or-self|preserve|previous|processing-instruction|record|return|satisfies|schema|schema-attribute|schema-element|self|sliding|some|stable|start|strict|strip|switch|text|then|to|treat|true|try|tumbling|type|typeswitch|union|unordered|validate|value|variable|version|when|where|while|window|xquery|zero-digit)\\b"
        }
      ]
    },
    "double_quoted_strings": {
      "name": "string.quoted.double.antlrquery",
      "begin": "\"",
      "end": "\"",
      "patterns": [
        {
          "name": "constant.character.escape.antlrquery",
          "match": "\"{2}"
        }
      ]
    },
    "single_quoted_strings": {
      "name": "string.quoted.single.antlrquery",
      "begin": "'",
      "end": "'",
      "patterns": [
        {
          "name": "constant.character.escape.antlrquery",
          "match": "'{2}"
        }
      ]
    },
    "variables": {
      "name": "variable.other.antlrquery",
      "match": "\\$[a-zA-Z_][a-zA-Z0-9_-]*"
    },
    "block_comments": {
      "name": "comment.block.antlrquery",
      "begin": "\\(\\:",
      "end": ":\\)",
      "patterns": [
        {
          "name": "punctuation.definition.comment.antlrquery",
          "match": "\\(\\:|:\\)"
        }
      ]
    },
    "numeric_literals": {
      "patterns": [
        {
          "name": "constant.numeric.integer.hex.antlrquery",
          "match": "\\b0[xX][0-9a-fA-F]([0-9a-fA-F_]*[0-9a-fA-F])?\\b"
        },
        {
          "name": "constant.numeric.integer.binary.antlrquery",
          "match": "\\b0[bB][01]([01_]*[01])?\\b"
        },
        {
          "name": "constant.numeric.float.antlrquery",
          "match": "\\b((\\d+(\\.\\d*)?)|(\\.\\d+))[eE][+-]?\\d+\\b"
        },
        {
          "name": "constant.numeric.float.antlrquery",
          "match": "\\b\\d+\\.\\d*\\b"
        },
        {
          "name": "constant.numeric.integer.decimal.antlrquery",
          "match": "\\b\\d([\\d_]*\\d)?\\b"
        }
      ]
    },
    "functions": {
      "patterns": [
        {
          "name": "support.function.antlrquery",
          "match": "\\b[a-zA-Z_][:a-zA-Z0-9_-]*#\\d+\\b"
        },
        {
          "name": "support.function.antlrquery",
          "match": "\\b[a-zA-Z_][:a-zA-Z0-9_-]*(?=\\()\\b"
        }
      ]
    },
    "types": {
      "patterns": [
        {
          "name": "storage.type.antlrquery",
          "match": "\\b(?:string|integer|int|boolean|float|double|decimal|date|dateTime|time|duration|anyType|anySimpleType|QName|base64Binary|hexBinary|IDREF|ID|ENTITY|NOTATION|token|language|Name|NCName|NMTOKEN|normalizedString|positiveInteger|nonNegativeInteger|nonPositiveInteger|negativeInteger|long|short|byte|unsignedLong|unsignedInt|unsignedShort|unsignedByte)[?*+]?\\b"
        }
      ]
    },
    "custom_types": {
      "patterns": [
        {
          "name": "entity.name.type.class",
          "match": "(?<=\\bas\\s)([a-zA-Z_][a-zA-Z0-9_-]*[?*+]?)\\b"
        },
        {
          "name": "entity.name.type.class",
          "match": "(?<=\\bcast\\s+as\\s)([a-zA-Z_][a-zA-Z0-9_-]*[?*+]?)\\b"
        },
        {
          "name": "entity.name.type.class",
          "match": "(?<=\\btreat\\s+as\\s)([a-zA-Z_][a-zA-Z0-9_-]*[?*+]?)\\b"
        },
        {
          "name": "entity.name.type.class",
          "match": "(?<=\\binstance\\s+of\\s)([a-zA-Z_][a-zA-Z0-9_-]*[?*+]?)\\b"
        }
      ]
    }
  }
}
