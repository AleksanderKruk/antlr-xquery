{
	"$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
	"name": "antlrquery",
	"patterns": [
		{
			"include": "#keywords"
		},
		{
			"include": "#double_quoted_strings"
		},
		{
			"include": "#single_quoted_strings"
		},
		{
			"include": "#variables"
		},
		{
			"include": "#block_comments"
		},
		{
			"include": "#numeric_literals"
		}
	],
	"repository": {
		"keywords": {
			"patterns": [{
				"name": "keyword.control.antlrquery",
				"match": "\\b(if|while|for|return|allowing|ancestor|ancestor-or-self|and|array|as|ascending|at|attribute|base-uri|boundary-space|by|case|cast|castable|catch|child|collation|comment|construction|context|copy-namespaces|count|decimal-format|decimal-separator|declare|default|descendant|descendant-or-self|descending|digit|div|document|document-node|element|else|empty|empty-sequence|encoding|end|enum|eq|every|except|exponent-separator|external|false|finally|fixed|fn|following|following-or-self|following-sibling|following-sibling-or-self|follows|for|function|ge|get|gnode|greatest|group|grouping-separator|gt|idiv|if|import|in|infinity|inherit|instance|intersect|is|is-not|item|jnode|key|lax|le|least|let|lt|map|member|minus-sign|mod|module|namespace|namespace-node|NaN|ne|next|no-inherit|no-preserve|node|of|only|option|or|order|ordered|ordering|otherwise|parent|pattern-separator|per-mille|percent|precedes|preceding|preceding-or-self|preceding-sibling|preceding-sibling-or-self|preserve|previous|processing-instruction|record|return|satisfies|schema|schema-attribute|schema-element|self|sliding|some|stable|start|strict|strip|switch|text|then|to|treat|true|try|tumbling|type|typeswitch|union|unordered|validate|value|variable|version|when|where|while|window|xquery|zero-digit)\\b"
			}]
		},
		"double_quoted_strings": {
			"name": "string.quoted.double.antlrquery",
			"begin": "\"",
			"end": "\"",
			"patterns": [
				{
					"name": "constant.character.escape.antlrquery",
					"match": "\"{2}"
				}
			]
		},
		"single_quoted_strings": {
			"name": "string.quoted.single.antlrquery",
			"begin": "'",
			"end": "'",
			"patterns": [
				{
					"name": "constant.character.escape.antlrquery",
					"match": "'{2}"
				}
			]
		},
		"variables": {
			"name": "variable.other.antlrquery",
			"match": "\\$[a-zA-Z_][a-zA-Z0-9_-]*"
		},
		"block_comments": {
			"name": "comment.block.antlrquery",
			"begin": "\\(\\:",
			"end": ":\\)",
			"patterns": [
				{
					"name": "punctuation.definition.comment.antlrquery",
					"match": "\\(\\:|:\\)"
				}
			]
		},
		"numeric_literals": {
			"patterns": [
				{
					"name": "constant.numeric.integer.hex.antlrquery",
					"match": "\\b0[xX][0-9a-fA-F]([0-9a-fA-F_]*[0-9a-fA-F])?\\b"
				},
				{
					"name": "constant.numeric.integer.binary.antlrquery",
					"match": "\\b0[bB][01]([01_]*[01])?\\b"
				},
				{
					"name": "constant.numeric.float.antlrquery",
					"match": "\\b((\\d+(\\.\\d*)?)|(\\.\\d+))[eE][+-]?\\d+\\b"
				},
				{
					"name": "constant.numeric.float.antlrquery",
					"match": "\\b\\d+\\.\\d*\\b"
				},
				{
					"name": "constant.numeric.integer.decimal.antlrquery",
					"match": "\\b\\d([\\d_]*\\d)?\\b"
				}
			]
		}
	},
	"scopeName": "source.antlrquery"
}
